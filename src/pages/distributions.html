<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>1D Data Generator</title>
<style>
body {
  font-family: Arial;
  padding: 20px;
  background: #f4f4f4;
  margin: 0;
}

.container {
  max-width: 960px;
  margin: auto;
  background: #fff;
  padding: 20px;
  border-radius: 10px;
}

.param-row { margin: 10px 0; }

button {
  padding: 8px 15px;
  margin: 5px;
  background: #4a7bd1;
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
}

button:hover { background: #3759a3; }

.arrow-btn {
  background: #888;
  width: 32px;
  font-weight: bold;
  padding: 5px 0;
}

.arrow-btn:hover {
  background: #666;
}

.graph-container {
  width: 100%;
  height: 420px;
  background: #eee;
  margin-top: 20px;
  position: relative;
}

.hist-container {
  width: 100%;
  height: 280px;
  background: #eee;
  margin-top: 20px;
  position: relative;
}

canvas {
  width: 100%;
  height: 100%;
}

.tooltip {
  position: fixed;
  background: #000;
  color: white;
  padding: 4px 7px;
  border-radius: 5px;
  pointer-events: none;
  display: none;
  font-size: 12px;
  z-index: 9999;
}

/* Legend styles */
.legend-box {
  display: inline-block;
  width: 14px;
  height: 8px;
  margin-right: 4px;
  vertical-align: middle;
}

.legend-mean {
  background: #2563eb;
}

.legend-std {
  background: #16a34a;
}
</style>
</head>
<body>

<div class="container">
  <h2>1D Data Generator</h2>

  <div class="param-row">
    <label>Category</label>
    <select id="category">
      <option value="discrete">Discrete</option>
      <option value="continuous" selected>Continuous</option>
    </select>
  </div>

  <div class="param-row">
    <label>Distribution</label>
    <select id="distribution"></select>
  </div>

  <div id="parameters"></div>

  <div class="param-row">
    <button onclick="generate(100)">100</button>
    <button onclick="generate(1000)">1,000</button>
    <button onclick="generate(10000)">10,000</button>
    <button onclick="generate(100000)">100,000</button>
    <button onclick="generate(1000000)">1,000,000</button>
  </div>

  <!-- Slider with arrow buttons -->
  <div class="param-row" id="sliderContainer" style="display:none;">
    Points to display

    <button id="leftArrow" class="arrow-btn">◀</button>

    <input id="displaySlider" type="range" min="0" value="0" style="width:300px;">

    <button id="rightArrow" class="arrow-btn">▶</button>

    <span id="displayCount"></span>
  </div>

  <!-- Point size slider -->
  <div class="param-row" id="pointSizeRow" style="display:none;">
    Point size
    <input id="pointSizeSlider" type="range" min="1" max="30" value="3" style="width:200px;">
    <span id="pointSizeLabel">3</span> px
  </div>

  <!-- Legend + toggles for running lines -->
  <div class="param-row" id="linesToggleRow" style="display:none;">
    <label>
      <input type="checkbox" id="toggleMean" checked>
      <span class="legend-box legend-mean"></span> Running average
    </label>
    &nbsp;&nbsp;
    <label>
      <input type="checkbox" id="toggleStd" checked>
      <span class="legend-box legend-std"></span> Running std dev
    </label>
  </div>

  <!-- Extra toggles (CI + true average) -->
  <div class="param-row" id="extraLinesRow" style="display:none;">
    <label>
      <input type="checkbox" id="toggleCI">
      Confidence interval
    </label>
    &nbsp;&nbsp;
    <label>
      <input type="checkbox" id="toggleOverallMean">
      True average line
    </label>
  </div>

  <!-- Confidence level slider (30–99%) -->
  <div class="param-row" id="ciSliderRow" style="display:none;">
    Confidence level
    <input id="ciSlider" type="range" min="30" max="99" step="1" value="95" style="width:400px;">
    <span id="ciLabel">95%</span>
  </div>

  <div class="graph-container">
    <canvas id="scatterCanvas"></canvas>
    <div id="tooltip" class="tooltip"></div>
  </div>

  <div class="hist-container">
    <canvas id="histCanvas"></canvas>
  </div>
</div>

<script>
// distributions
const discrete = ["Bernoulli", "Binomial", "Geometric", "Poisson"];
const continuous = ["Uniform", "Normal", "Exponential", "Gamma"];

let data = [];
let displayedPoints = 0;

let histogramBars = [];
let pointPositions = [];

// which bin is hovered: {min, max} or null
let hoveredBinRange = null;

// toggles and point size
let showMean = true;
let showStd = true;
let pointSize = 3;

// CI and true average line toggles
let showCI = false;
let showOverallMean = false;  // "True average line"
let ciLevel = 95; // percent

const scatterCanvas = document.getElementById("scatterCanvas");
const scatterCtx = scatterCanvas.getContext("2d");

const histCanvas = document.getElementById("histCanvas");
const histCtx = histCanvas.getContext("2d");

const tooltip = document.getElementById("tooltip");

function resizeCanvas(canvas) {
  canvas.width = canvas.offsetWidth;
  canvas.height = canvas.offsetHeight;
}

// UI setup
const categorySel = document.getElementById("category");
const distSel = document.getElementById("distribution");
const paramDiv = document.getElementById("parameters");

function updateDistributionOptions() {
  distSel.innerHTML = "";
  const list = categorySel.value === "discrete" ? discrete : continuous;
  list.forEach(d => {
    const opt = document.createElement("option");
    opt.textContent = d;
    opt.value = d;
    distSel.appendChild(opt);
  });
  updateParameters();
}

function updateParameters() {
  const dist = distSel.value;
  paramDiv.innerHTML = "";

  const inp = (label, id, val) => {
    const row = document.createElement("div");
    row.className = "param-row";
    row.innerHTML = `${label}: <input id="${id}" type="number" value="${val}" step="any">`;
    paramDiv.appendChild(row);
  };

  if (dist === "Bernoulli") inp("p", "p", 0.5);
  if (dist === "Binomial") { inp("n", "n", 10); inp("p", "p", 0.5); }
  if (dist === "Geometric") inp("p", "p", 0.3);
  if (dist === "Poisson") inp("λ", "lambda", 4);
  if (dist === "Uniform") { inp("a", "a", 0); inp("b", "b", 1); }
  if (dist === "Normal") { inp("μ", "mu", 0); inp("σ", "sigma", 1); }
  if (dist === "Exponential") inp("λ", "lambda", 1);
  if (dist === "Gamma") { inp("k", "k", 2); inp("θ", "theta", 2); }
}

// RNG helpers
function randn() {
  let u=0,v=0;
  while(u===0) u=Math.random();
  while(v===0) v=Math.random();
  return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v);
}

// Theoretical true mean based on distribution parameters
function getTrueMean() {
  const dist = distSel.value;

  const p = parseFloat(document.getElementById("p")?.value);
  const nBin = parseFloat(document.getElementById("n")?.value);
  const a = parseFloat(document.getElementById("a")?.value);
  const b = parseFloat(document.getElementById("b")?.value);
  const mu = parseFloat(document.getElementById("mu")?.value);
  const lambda = parseFloat(document.getElementById("lambda")?.value);
  const kshape = parseFloat(document.getElementById("k")?.value);
  const theta = parseFloat(document.getElementById("theta")?.value);

  if (dist === "Bernoulli") {
    if (!isFinite(p)) return null;
    return p;
  }
  if (dist === "Binomial") {
    if (!isFinite(nBin) || !isFinite(p)) return null;
    return nBin * p;
  }
  if (dist === "Geometric") { // support starting at 1
    if (!isFinite(p) || p <= 0) return null;
    return 1 / p;
  }
  if (dist === "Poisson") {
    if (!isFinite(lambda)) return null;
    return lambda;
  }
  if (dist === "Uniform") {
    if (!isFinite(a) || !isFinite(b)) return null;
    return (a + b) / 2;
  }
  if (dist === "Normal") {
    if (!isFinite(mu)) return null;
    return mu;
  }
  if (dist === "Exponential") {
    if (!isFinite(lambda) || lambda <= 0) return null;
    return 1 / lambda;
  }
  if (dist === "Gamma") {
    if (!isFinite(kshape) || !isFinite(theta)) return null;
    return kshape * theta;
  }
  return null;
}

// generate data
function generate(n) {
  const dist = distSel.value;

  const p = parseFloat(document.getElementById("p")?.value);
  const nBin = parseInt(document.getElementById("n")?.value);
  const a = parseFloat(document.getElementById("a")?.value);
  const b = parseFloat(document.getElementById("b")?.value);
  const mu = parseFloat(document.getElementById("mu")?.value);
  const sigma = parseFloat(document.getElementById("sigma")?.value);
  const lambda = parseFloat(document.getElementById("lambda")?.value);
  const kshape = parseFloat(document.getElementById("k")?.value);
  const theta = parseFloat(document.getElementById("theta")?.value);

  data = [];

  for (let i=0;i<n;i++) {
    if (dist === "Bernoulli") data.push(Math.random()<p ? 1:0);
    else if (dist === "Binomial") {
      let s=0; for (let j=0;j<nBin;j++) if (Math.random()<p) s++;
      data.push(s);
    }
    else if (dist === "Geometric") {
      let c=1; while(Math.random()>p) c++; data.push(c);
    }
    else if (dist === "Poisson") {
      let L=Math.exp(-lambda), k=0, t=1;
      do { k++; t*=Math.random(); } while(t>L);
      data.push(k-1);
    }
    else if (dist === "Uniform") data.push(a + Math.random()*(b-a));
    else if (dist === "Normal") data.push(mu + sigma*randn());
    else if (dist === "Exponential") data.push(-Math.log(1-Math.random())/lambda);
    else if (dist === "Gamma") {
      let s=0; for (let j=0;j<kshape;j++) s += -Math.log(Math.random());
      data.push(s * theta);
    }
  }

  const slider = document.getElementById("displaySlider");

  // Preserve previous displayedPoints / slider value if possible
  let previousDisplay = displayedPoints || parseInt(slider.value) || 0;

  // Update slider max for new sample size
  slider.max = n;

  // If we had a previous display count, keep it (clamped to new max)
  if (previousDisplay > 0) {
    const newDisplay = Math.min(previousDisplay, n);
    slider.value = newDisplay;
    displayedPoints = newDisplay;
  } else {
    slider.value = n;
    displayedPoints = n;
  }

  document.getElementById("displayCount").textContent = displayedPoints;
  document.getElementById("sliderContainer").style.display = "block";
  document.getElementById("linesToggleRow").style.display = "block";
  document.getElementById("pointSizeRow").style.display = "block";
  document.getElementById("extraLinesRow").style.display = "block";

  // If CI is currently enabled, keep the slider visible
  const ciSliderRow = document.getElementById("ciSliderRow");
  ciSliderRow.style.display = showCI ? "block" : "none";

  drawScatter();
  drawHistogram();
}

// axes
function drawAxes(ctx, W, H, minY, maxY, xLabel, yLabel) {
  const marginLeft = 60;
  const marginBottom = 40;

  ctx.strokeStyle = "#cccccc";
  ctx.beginPath();
  ctx.moveTo(marginLeft, H - marginBottom);
  ctx.lineTo(W - 20, H - marginBottom);
  ctx.stroke();

  ctx.strokeStyle = "#000";
  ctx.beginPath();
  ctx.moveTo(marginLeft, 20);
  ctx.lineTo(marginLeft, H - marginBottom);
  ctx.stroke();

  ctx.textAlign = "center";
  ctx.font = "14px Arial";
  ctx.fillText(xLabel, W/2, H - 5);

  ctx.save();
  ctx.translate(15, H/2);
  ctx.rotate(-Math.PI/2);
  ctx.fillText(yLabel, 0, 0);
  ctx.restore();

  const ticks = 5;
  ctx.font = "12px Arial";
  ctx.textAlign = "right";

  for (let i=0;i<=ticks;i++) {
    const t = i/ticks;
    const yVal = minY + t*(maxY - minY);
    const yPix = (1-t)*(H - marginBottom - 20) + 20;

    ctx.beginPath();
    ctx.moveTo(marginLeft-5, yPix);
    ctx.lineTo(marginLeft, yPix);
    ctx.stroke();

    ctx.fillText(yVal.toFixed(3), marginLeft-8, yPix+4);
  }
}

// Normal inverse CDF (Acklam approximation)
function normInv(p) {
  if (p <= 0 || p >= 1) {
    throw new Error("p must be in (0,1)");
  }

  const a = [
    -3.969683028665376e+01,
     2.209460984245205e+02,
    -2.759285104469687e+02,
     1.383577518672690e+02,
    -3.066479806614716e+01,
     2.506628277459239e+00
  ];

  const b = [
    -5.447609879822406e+01,
     1.615858368580409e+02,
    -1.556989798598866e+02,
     6.680131188771972e+01,
    -1.328068155288572e+01
  ];

  const c = [
    -7.784894002430293e-03,
    -3.223964580411365e-01,
    -2.400758277161838e+00,
    -2.549732539343734e+00,
     4.374664141464968e+00,
     2.938163982698783e+00
  ];

  const d = [
     7.784695709041462e-03,
     3.224671290700398e-01,
     2.445134137142996e+00,
     3.754408661907416e+00
  ];

  const plow = 0.02425;
  const phigh = 1 - plow;
  let q, r;

  if (p < plow) {
    q = Math.sqrt(-2 * Math.log(p));
    return (((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5]) /
           ((((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1);
  } else if (phigh < p) {
    q = Math.sqrt(-2 * Math.log(1 - p));
    return -(((((c[0]*q + c[1])*q + c[2])*q + c[3])*q + c[4])*q + c[5]) /
             ((((d[0]*q + d[1])*q + d[2])*q + d[3])*q + 1);
  } else {
    q = p - 0.5;
    r = q * q;
    return (((((a[0]*r + a[1])*r + a[2])*r + a[3])*r + a[4])*r + a[5]) * q /
           (((((b[0]*r + b[1])*r + b[2])*r + b[3])*r + b[4])*r + 1);
  }
}

// For a two-sided confidence level in percent, return z
function getZ(confPercent) {
  const c = confPercent / 100;
  const alpha = 1 - c;
  const p = 1 - alpha / 2;
  return normInv(p);
}

// helper to draw static label boxes (always-visible tooltips)
function drawLabel(ctx, x, y, text, W, H) {
  ctx.save();
  ctx.font = "11px Arial";
  ctx.textBaseline = "middle";
  ctx.textAlign = "left";

  const paddingX = 4;
  const paddingY = 2;
  const metrics = ctx.measureText(text);
  const textWidth = metrics.width;
  const boxW = textWidth + 2 * paddingX;
  const boxH = 12 + 2 * paddingY;

  let bx = x;
  let by = y - boxH / 2;

  // clamp inside canvas
  if (bx + boxW > W - 5) bx = W - 5 - boxW;
  if (bx < 5) bx = 5;
  if (by < 5) by = 5;
  if (by + boxH > H - 5) by = H - 5 - boxH;

  ctx.fillStyle = "rgba(0,0,0,0.7)";
  ctx.fillRect(bx, by, boxW, boxH);

  ctx.fillStyle = "#ffffff";
  ctx.fillText(text, bx + paddingX, by + boxH / 2);

  ctx.restore();
}

// scatter + running stats
function drawScatter() {
  resizeCanvas(scatterCanvas);
  const ctx = scatterCtx;
  ctx.clearRect(0,0,scatterCanvas.width,scatterCanvas.height);

  if (displayedPoints === 0 || data.length === 0) return;

  const W = scatterCanvas.width;
  const H = scatterCanvas.height;

  const marginLeft = 60;
  const marginBottom = 40;
  const topMargin = 20;

  const N = Math.min(displayedPoints, data.length);

  const runningMean = new Array(N);
  const runningStd = new Array(N);
  let sum = 0;
  let sumSq = 0;

  let minY = Infinity;
  let maxY = -Infinity;

  for (let i = 0; i < N; i++) {
    const v = data[i];
    sum += v;
    sumSq += v * v;
    const n = i + 1;
    const mean = sum / n;
    const variance = n > 1 ? (sumSq / n - mean * mean) : 0;
    const std = Math.sqrt(Math.max(variance, 0));

    runningMean[i] = mean;
    runningStd[i] = std;

    if (v < minY) minY = v;
    if (v > maxY) maxY = v;
    if (showMean) {
      if (mean < minY) minY = mean;
      if (mean > maxY) maxY = mean;
    }
    if (showStd) {
      if (std < minY) minY = std;
      if (std > maxY) maxY = std;
    }
  }

  // Theoretical true average from parameters
  const trueMean = getTrueMean();

  // Sample mean of first N points (for CI)
  let sampleMean = null;
  if (N > 0) {
    sampleMean = runningMean[N - 1];
  }

  // Confidence interval bounds (sample-based)
  let ciLower = null;
  let ciUpper = null;
  if (showCI && N > 1) {
    const z = getZ(ciLevel);
    const stdFinal = runningStd[N - 1];
    const margin = z * stdFinal / Math.sqrt(N);
    ciLower = sampleMean - margin;
    ciUpper = sampleMean + margin;
    if (ciLower < minY) minY = ciLower;
    if (ciUpper > maxY) maxY = ciUpper;
  }

  // Enforce vertical symmetry around trueMean if it exists
  if (trueMean != null && isFinite(trueMean)) {
    let distBelow = trueMean - minY;
    let distAbove = maxY - trueMean;
    let maxDist = Math.max(distBelow, distAbove);
    if (!(maxDist > 0)) {
      maxDist = 1;
    }
    minY = trueMean - maxDist;
    maxY = trueMean + maxDist;
  }

  if (maxY === minY) {
    maxY += 1;
    minY -= 1;
  }

  drawAxes(ctx, W, H, minY, maxY, "Sample Index", "Value");

  const effectiveW = W - marginLeft - 20;
  const effectiveH = H - marginBottom - topMargin;

  const valueToY = (val) =>
    (1 - (val - minY) / (maxY - minY + 1e-12)) * effectiveH + topMargin;

  pointPositions = [];

  // If a histogram bin is hovered, draw a translucent blue band for that value range
  if (hoveredBinRange && isFinite(hoveredBinRange.min) && isFinite(hoveredBinRange.max)) {
    const y1 = valueToY(hoveredBinRange.max);
    const y2 = valueToY(hoveredBinRange.min);
    const yTop = Math.min(y1, y2);
    const height = Math.abs(y2 - y1);

    ctx.fillStyle = "rgba(59, 130, 246, 0.18)"; // translucent blue
    ctx.fillRect(marginLeft, yTop, effectiveW, height);
  }

  // Confidence interval band + static labels for bounds (now light orange fill)
  let yLower, yUpper;
  if (showCI && N > 1 && ciLower != null && ciUpper != null) {
    yLower = valueToY(ciLower);
    yUpper = valueToY(ciUpper);
    const yTop = Math.min(yLower, yUpper);
    const height = Math.abs(yUpper - yLower);

    ctx.fillStyle = "rgba(249, 115, 22, 0.15)";   // light orange
    ctx.fillRect(marginLeft, yTop, effectiveW, height);

    ctx.strokeStyle = "rgba(249, 115, 22, 0.7)";
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(marginLeft, yLower);
    ctx.lineTo(marginLeft + effectiveW, yLower);
    ctx.moveTo(marginLeft, yUpper);
    ctx.lineTo(marginLeft + effectiveW, yUpper);
    ctx.stroke();
  }

  // Data points
  const hoverRadius = Math.max(5, pointSize);
  ctx.fillStyle = "#222";

  for (let i = 0; i < N; i++) {
    const x = N > 1
      ? marginLeft + (i / (N - 1)) * effectiveW
      : marginLeft + effectiveW / 2;
    const y = valueToY(data[i]);

    ctx.fillRect(x - pointSize / 2, y - pointSize / 2, pointSize, pointSize);

    pointPositions.push({ x, y, index: i, value: data[i], r: hoverRadius });
  }

  // Running mean line + small highlight circle + static tooltip
  if (showMean) {
    ctx.strokeStyle = "#2563eb";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < N; i++) {
      const x = N > 1
        ? marginLeft + (i / (N - 1)) * effectiveW
        : marginLeft + effectiveW / 2;
      const y = valueToY(runningMean[i]);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    if (N > 0) {
      const lastIndex = N - 1;
      const xLastMean = N > 1
        ? marginLeft + (lastIndex / (N - 1)) * effectiveW
        : marginLeft + effectiveW / 2;
      const yLastMean = valueToY(runningMean[lastIndex]);

      ctx.beginPath();
      ctx.arc(xLastMean, yLastMean, 7, 0, 2 * Math.PI);
      ctx.fillStyle = "#2563eb";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#ffffff";
      ctx.stroke();

      const labelText = "Mean: " + runningMean[lastIndex].toFixed(3);
      drawLabel(ctx, xLastMean + 10, yLastMean - 12, labelText, W, H);
    }
  }

  // Running std line + small highlight circle + static tooltip
  if (showStd) {
    ctx.strokeStyle = "#16a34a";
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i < N; i++) {
      const x = N > 1
        ? marginLeft + (i / (N - 1)) * effectiveW
        : marginLeft + effectiveW / 2;
      const y = valueToY(runningStd[i]);
      if (i === 0) ctx.moveTo(x, y);
      else ctx.lineTo(x, y);
    }
    ctx.stroke();

    if (N > 0) {
      const lastIndex = N - 1;
      const xLastStd = N > 1
        ? marginLeft + (lastIndex / (N - 1)) * effectiveW
        : marginLeft + effectiveW / 2;
      const yLastStd = valueToY(runningStd[lastIndex]);

      ctx.beginPath();
      ctx.arc(xLastStd, yLastStd, 7, 0, 2 * Math.PI);
      ctx.fillStyle = "#16a34a";
      ctx.fill();
      ctx.lineWidth = 2;
      ctx.strokeStyle = "#ffffff";
      ctx.stroke();

      const labelText = "Std: " + runningStd[lastIndex].toFixed(3);
      drawLabel(ctx, xLastStd + 10, yLastStd + 12, labelText, W, H);
    }
  }

  // True average horizontal line (theoretical mean) + static tooltip
  if (showOverallMean && trueMean != null && isFinite(trueMean)) {
    const yTrue = valueToY(trueMean);
    ctx.strokeStyle = "#f97316";
    ctx.lineWidth = 2;
    ctx.setLineDash([6, 4]);
    ctx.beginPath();
    ctx.moveTo(marginLeft, yTrue);
    ctx.lineTo(marginLeft + effectiveW, yTrue);
    ctx.stroke();
    ctx.setLineDash([]);

    const labelText = "True μ: " + trueMean.toFixed(3);
    const xLabel = marginLeft + 10; // left side of graph
    drawLabel(ctx, xLabel, yTrue, labelText, W, H);
  }

  // Static labels for CI bounds (both ends)
  if (showCI && N > 1 && ciLower != null && ciUpper != null) {
    const labelLow = "CI low: " + ciLower.toFixed(3);
    const labelHigh = "CI high: " + ciUpper.toFixed(3);
    const xLabel = marginLeft + 10;   // keep near left side

    const yLowPix = valueToY(ciLower);
    const yHighPix = valueToY(ciUpper);

    // Low bound label below its line
    drawLabel(ctx, xLabel, yLowPix + 14, labelLow, W, H);

    // High bound label above its line
    drawLabel(ctx, xLabel, yHighPix - 14, labelHigh, W, H);
  }
}

// decision rule for bins: sqrt(n) clamped to [5, 60]
function getBinCount(n) {
  if (n <= 1) return 1;
  const k = Math.round(Math.sqrt(n));
  return Math.max(5, Math.min(60, k));
}

// histogram for first displayedPoints samples
function drawHistogram() {
  resizeCanvas(histCanvas);
  const ctx = histCtx;
  ctx.clearRect(0,0,histCanvas.width,histCanvas.height);

  if (data.length === 0 || displayedPoints === 0) return;

  const N = Math.min(displayedPoints, data.length);
  const subset = data.slice(0, N);

  const W = histCanvas.width;
  const H = histCanvas.height;

  const marginLeft = 60;
  const marginBottom = 40;

  const bins = getBinCount(N);
  const min = Math.min(...subset);
  const max = Math.max(...subset);
  const binSize = (max - min) / bins || 1;

  const counts = new Array(bins).fill(0);
  subset.forEach(v => {
    const idx = Math.min(bins-1, Math.floor((v-min)/binSize));
    counts[idx]++;
  });

  const maxCount = Math.max(...counts);

  drawAxes(ctx, W, H, 0, maxCount, "Value Range (bins)", "Frequency");

  const effectiveW = W - marginLeft - 20;
  const effectiveH = H - marginBottom - 20;
  const barW = effectiveW / bins;

  histogramBars = [];

  ctx.fillStyle = "#4a7bd1";
  for (let i=0;i<bins;i++) {
    const h = maxCount > 0 ? (counts[i]/maxCount)*effectiveH : 0;
    const x = marginLeft + i*barW;
    const y = H - marginBottom - h;

    ctx.fillRect(x,y,barW-2,h);

    histogramBars.push({
      x, y, w: barW-2, h,
      binIndex: i,
      count: counts[i],
      minVal: min + i*binSize,
      maxVal: min + (i+1)*binSize
    });
  }
}

// scatter hover tooltip
scatterCanvas.addEventListener("mousemove", e => {
  const rect = scatterCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  let found = null;

  for (let p of pointPositions) {
    const dx = p.x - mx;
    const dy = p.y - my;
    if (dx*dx + dy*dy <= p.r*p.r) {
      found = p;
      break;
    }
  }

  if (found) {
    tooltip.style.display = "block";
    tooltip.textContent = `Index ${found.index} | Value ${found.value.toFixed(4)}`;
    tooltip.style.left = (e.clientX + 12) + "px";
    tooltip.style.top  = (e.clientY + 12) + "px";
  } else {
    tooltip.style.display = "none";
  }
});

// histogram hover tooltip + linking band
histCanvas.addEventListener("mousemove", e => {
  const rect = histCanvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  let found = null;

  for (let b of histogramBars) {
    if (mx >= b.x && mx <= b.x+b.w && my >= b.y && my <= b.y+b.h) {
      found = b;
      break;
    }
  }

  if (found) {
    tooltip.style.display = "block";
    tooltip.textContent =
      `Bin ${found.binIndex}
Value range: [${found.minVal.toFixed(4)}, ${found.maxVal.toFixed(4)}]
Count: ${found.count}`;
    tooltip.style.left = (e.clientX + 12) + "px";
    tooltip.style.top  = (e.clientY + 12) + "px";

    hoveredBinRange = { min: found.minVal, max: found.maxVal };
    drawScatter();
  } else {
    tooltip.style.display = "none";
    if (hoveredBinRange !== null) {
      hoveredBinRange = null;
      drawScatter();
    }
  }
});

histCanvas.addEventListener("mouseleave", () => {
  hoveredBinRange = null;
  tooltip.style.display = "none";
  drawScatter();
});

// slider and arrows
const slider = document.getElementById("displaySlider");
const leftArrow = document.getElementById("leftArrow");
const rightArrow = document.getElementById("rightArrow");

let arrowInterval = null;
const arrowSpeed = 50;
const arrowStep = 1;

function startArrow(direction) {
  stopArrow();

  arrowInterval = setInterval(() => {
    let v = parseInt(slider.value);
    const max = parseInt(slider.max);

    if (direction === -1 && v > 0) v -= arrowStep;
    if (direction === 1 && v < max) v += arrowStep;

    slider.value = v;
    displayedPoints = v;
    document.getElementById("displayCount").textContent = v;
    drawScatter();
    drawHistogram();
  }, arrowSpeed);
}

function stopArrow() {
  if (arrowInterval) clearInterval(arrowInterval);
  arrowInterval = null;
}

leftArrow.addEventListener("mousedown", () => startArrow(-1));
leftArrow.addEventListener("mouseup", stopArrow);
leftArrow.addEventListener("mouseleave", stopArrow);

rightArrow.addEventListener("mousedown", () => startArrow(1));
rightArrow.addEventListener("mouseup", stopArrow);
rightArrow.addEventListener("mouseleave", stopArrow);

slider.addEventListener("input", e => {
  displayedPoints = parseInt(e.target.value);
  document.getElementById("displayCount").textContent = displayedPoints;
  drawScatter();
  drawHistogram();
});

// toggles and sliders
const toggleMean = document.getElementById("toggleMean");
const toggleStd = document.getElementById("toggleStd");
const pointSizeSlider = document.getElementById("pointSizeSlider");
const pointSizeLabel = document.getElementById("pointSizeLabel");

const toggleCI = document.getElementById("toggleCI");
const toggleOverallMean = document.getElementById("toggleOverallMean");
const ciSlider = document.getElementById("ciSlider");
const ciLabel = document.getElementById("ciLabel");
const ciSliderRow = document.getElementById("ciSliderRow");

toggleMean.addEventListener("change", () => {
  showMean = toggleMean.checked;
  drawScatter();
});

toggleStd.addEventListener("change", () => {
  showStd = toggleStd.checked;
  drawScatter();
});

pointSizeSlider.addEventListener("input", () => {
  pointSize = parseInt(pointSizeSlider.value);
  pointSizeLabel.textContent = pointSize;
  drawScatter();
});

toggleCI.addEventListener("change", () => {
  showCI = toggleCI.checked;
  ciSliderRow.style.display = showCI ? "block" : "none";
  drawScatter();
});

toggleOverallMean.addEventListener("change", () => {
  showOverallMean = toggleOverallMean.checked;
  drawScatter();
});

ciSlider.addEventListener("input", () => {
  ciLevel = parseInt(ciSlider.value);
  ciLabel.textContent = ciLevel + "%";
  if (showCI) drawScatter();
});

// init (default: Continuous / Normal)
categorySel.addEventListener("change", updateDistributionOptions);
distSel.addEventListener("change", updateParameters);

// Build options based on initial category, then set Normal by default
updateDistributionOptions();
distSel.value = "Normal";
updateParameters();
</script>

</body>
</html>
